# Pre-Facet Calibration Pipeline
#
# Basic Pre-Facet Calibration Pipeline:
# - no demixing but A-team flagging,
# - only averaging target data after calibration transfer
# - consecutive subband-numbers in the data need to be consecutive subband-frequencies
# - the new "error_tolerance" option requires LOFAR software version >= 2.15
#   (Comment out all lines with "error_tolerance" if you want to use an older version.)
# - expects shared filesystem, that all nodes can reach all files!
#   (E.g. a single workstation or compute cluster with shared filesystem
#   doesn't work on multiple nodes on CEP-2 or CEP3.)

### First run this and check the generated plots! Modify and re-run if neccessary.
pipeline.steps=[createmap_cal, ndppp_prep_cal, calib_cal, h5_imp_map, h5imp_cal, fitclock, ampl, plots, phase]
### When calibrator processing is done, you can do the processing of the target data.
### Either by using the same pipeline and running this:
# pipeline.steps=[createmap_cal, ndppp_prep_cal, calib_cal, h5_imp_map, h5imp_cal, fitclock, ampl, plots, phase, createmap_target, trans, parmmap, ndppp_trans_target, ateamtarget, ateamcliptar, sortmap_tar, target_skymodel, target_sourcedb, expand_target_sourcedb_map, dpppconcat_target, directionindependent_parmmap, dpppcalib_target, applytarget, plot_target_phases, make_results_mapfile, move_results, createmap_plots, copy_plots]
### Or by copying the *.npy files from the calibrator and running this:
# pipeline.steps=[createmap_target, trans, parmmap, ndppp_trans_target, ateamtarget, ateamcliptar, sortmap_tar, target_skymodel, target_sourcedb, expand_target_sourcedb_map, dpppconcat_target, directionindependent_parmmap, dpppcalib_target, applytarget, plot_target_phases, make_results_mapfile, move_results, createmap_plots, copy_plots]


# parameters you will need to adjust.
! avg_timestep         = 2   # averaging step needed to average the data to 4 seconds time resolution
! avg_freqstep         = 2   # averaging step needed to average the data to 4 ch/SB frequency resolution
! cal_input_path       = /data/scratch/username/PathToYourCalibratorData/
! cal_input_pattern    = L*.MS
! calibrator_skymodel  = /cep3home/username/Pre-Facet-Cal/skymodels/PleaseProvideCalibrator.skymodel
! target_input_path    = /data/scratch/username/PathToYourTargetData/
! target_input_pattern = L*.MS
! target_skymodel      = /cep3home/username/Pre-Facet-Cal/skymodels/PleaseProvideTarget.skymodel
! num_SBs_per_group    = 12   # make concatenated measurement-sets with that many subbands
! results_directory    = /media/scratch/test/username/WhereYouWantYourProcessedData/

# pathes to the scripts etc.
# #### ToDo: get the scripts onto CEP3 and adjust the pathes here!
! calib_cal_parset     = /cep3home/horneffer/Pre-Facet-Cal/parsets/calibcal.parset
! cal_transfer_parset  = /cep3home/horneffer/Pre-Facet-Cal/parsets/applyparmdb.parset
! ATeam_predict_parset = /cep3home/horneffer/Pre-Facet-Cal/parsets/ateamclip.parset
! ATeam_skymodel       = /cep3home/horneffer/Pre-Facet-Cal/skymodels/Ateam_LBA_CC.skymodel
! losoto_importer      = /cep3home/horneffer/Pre-Facet-Cal/bin/losotoImporter.py
! fitclock_script      = /cep3home/horneffer/Pre-Facet-Cal/bin/fit_clocktec_initialguess_losoto.py
! fitamps_script       = /cep3home/horneffer/Pre-Facet-Cal/bin/amplitudes_losoto_3.py
! plotsols_script      = /cep3home/horneffer/Pre-Facet-Cal/bin/examine_npys.py
! fit_XYoffset_script  = /cep3home/horneffer/Pre-Facet-Cal/bin/find_cal_global_phaseoffset_losoto.py
! transfer_script      = /cep3home/horneffer/Pre-Facet-Cal/bin/transfer_amplitudes+clock+offset_toMS.py
! ATeam_Clipper        = /cep3home/horneffer/Pre-Facet-Cal/bin/Ateamclipper.py
! plotphases_script    = /cep3home/horneffer/Pre-Facet-Cal/bin/plot_solutions_all_stations.py
! flagging_strategy    = /opt/cep/lofar/lofar_versions/LOFAR-Release-2_12_0/lofar_build/install/gnu_opt/share/rfistrategies/HBAdefault

# set this to True if you want the pipeline run to continue if single bands fail
! error_tolerance           =  False

# generate a mapfile of all the calibrator data
createmap_cal.control.kind            =   plugin
createmap_cal.control.type            =   createMapfile
createmap_cal.control.method          =   mapfile_from_folder
createmap_cal.control.mapfile_dir     =   input.output.mapfile_dir
createmap_cal.control.filename        =   createmap_cal.mapfile
createmap_cal.control.folder          =   {{ cal_input_path }}
createmap_cal.control.pattern         =   {{ cal_input_pattern }}

# run NDPPP on the calibrator data
ndppp_prep_cal.control.type              = dppp
ndppp_prep_cal.control.max_per_node      = 10                   # \ feel free to adjust these two values to match your system
ndppp_prep_cal.control.environment       = {OMP_NUM_THREADS: 4} # / they should be reasonable for CEP3
ndppp_prep_cal.control.error_tolerance   = {{ error_tolerance }}
ndppp_prep_cal.argument.msin             = createmap_cal.output.mapfile    # The input data.
ndppp_prep_cal.argument.msin.datacolumn  = DATA
ndppp_prep_cal.argument.msin.baseline    = CS*&; RS*&; CS*&RS*
ndppp_prep_cal.argument.msout.datacolumn = DATA
ndppp_prep_cal.argument.steps            = [flag,filter,avg,flagamp]
ndppp_prep_cal.argument.flag.type        = preflagger
ndppp_prep_cal.argument.flag.baseline    = [ CS013HBA* ]            # feel free to change that, but CS013 is usually bad.
ndppp_prep_cal.argument.filter.type      = filter
ndppp_prep_cal.argument.filter.baseline  = CS*, RS*&&
ndppp_prep_cal.argument.filter.remove    = true                     # fully kick out the international stations.
ndppp_prep_cal.argument.avg.type         = average
ndppp_prep_cal.argument.avg.timestep     = {{ avg_timestep }}       # average to 4 second intervals , PLEASE ADJUST!
ndppp_prep_cal.argument.avg.freqstep     = {{ avg_freqstep }}       # average to 2 ch/SB , PLEASE ADJUST!
ndppp_prep_cal.argument.flagamp.type     = preflagger
ndppp_prep_cal.argument.flagamp.amplmin  = 1e-30

#now run BBS on the NDPPP-ed calibrator data.
calib_cal.control.type             =  python-calibrate-stand-alone
calib_cal.control.max_per_node     =  24                         # feel free to adjust this value to match your system
calib_cal.control.error_tolerance  =  {{ error_tolerance }}
calib_cal.argument.force           =  True
calib_cal.argument.observation     =  ndppp_prep_cal.output.mapfile  # mapfile for the NDPPP-ed calibrator data
calib_cal.argument.parset          =  {{ calib_cal_parset }}
calib_cal.argument.catalog         =  {{ calibrator_skymodel }}

# generate a mapfile with all files in a single entry
h5_imp_map.control.kind               =  plugin
h5_imp_map.control.type               =  createMapfile
h5_imp_map.control.method             =  mapfile_all_to_one
h5_imp_map.control.mapfile_in         =  ndppp_prep_cal.output.mapfile
h5_imp_map.control.mapfile_dir        =  input.output.mapfile_dir
h5_imp_map.control.filename           =  h5_imp_map.mapfile

# import all instrument tables into one LoSoTo file
h5imp_cal.control.type            =  pythonplugin
h5imp_cal.control.executable      =  {{ losoto_importer }}
h5imp_cal.argument.flags          =  [h5_imp_map.output.mapfile,h5imp_cal_losoto.h5]
h5imp_cal.argument.instrument     =  /instrument
h5imp_cal.argument.solsetName     =  sol000
h5imp_cal.argument.compression    =  7

# now run the script that does the clock-TEC fitting
fitclock.control.kind             = recipe
fitclock.control.type             = executable_args
fitclock.control.mapfile_in       = h5imp_cal.output.h5parm.mapfile
fitclock.control.executable       = {{ fitclock_script }}
# order for arguments is: [<input-filename>,<output-filename-base>,<NumThreads>]
fitclock.control.arguments        = [h5gvds,caldata_transfer,24]
fitclock.control.inputkey         = h5gvds

# now run the script that filters the amplitudes
ampl.control.kind             = recipe
ampl.control.type             = executable_args
ampl.control.mapfile_in       = h5imp_cal.output.h5parm.mapfile
ampl.control.executable       = {{ fitamps_script }}
# order for arguments is: [<input-filename>,<output-filename-base>,<num-ch/SB>,<subbans-to-flag>]
# subbans-to-flag = semicolon-sperated list of integers in double-quotes
# e.g.: ampl.control.arguments   = [h5gvds,caldata_transfer,4,"205;206;207"]
ampl.control.arguments        = [h5gvds,caldata_transfer,4,""]
ampl.control.inputkey         = h5gvds

# and generate some output plots
plots.control.kind             = recipe
plots.control.type             = executable_args
plots.control.mapfile_in       = h5imp_cal.output.h5parm.mapfile
plots.control.executable       = {{ plotsols_script }}
plots.control.skip_infile      = True
plots.control.arguments        = [caldata_transfer]   # Needs "<output-filename-base>" from the fitclock and ampl steps

# fit the phase difference between X and Y
phase.control.type            = pythonplugin
phase.control.executable      = {{ fit_XYoffset_script }}
# order for flags is: [<input-filename>,<output-filename-base>]
phase.argument.flags          = [h5imp_cal.output.h5parm.mapfile,caldata_transfer]


# ############################################################################################################
# # Stop processing here and check the plots generated by the previous steps! Only then continue processing. #
# ############################################################################################################


# generate a mapfile of all the target data
createmap_target.control.kind            =   plugin
createmap_target.control.type            =   createMapfile
createmap_target.control.method          =   mapfile_from_folder
createmap_target.control.mapfile_dir     =   input.output.mapfile_dir
createmap_target.control.filename        =   createmap_target.mapfile
createmap_target.control.folder          =   {{ target_input_path }}
createmap_target.control.pattern         =   {{ target_input_pattern }}

# generate parmDB with the interpolated calibrator data to apply to the traget
trans.control.type            = pythonplugin
trans.control.executable      = {{ transfer_script }}
trans.control.max_per_node    =  20                                 # feel free to adjust this value to match your system
trans.control.error_tolerance = {{ error_tolerance }}
# order for flags is: [<input-filenames>,<output-filename-base>,<extension_for_new_parmDBs>]
trans.argument.flags          = [createmap_target.output.mapfile,caldata_transfer,/instrument_amp_clock_offset]

# generate mapfile with the parmDBs to be applied to the target data
parmmap.control.kind               =  plugin
parmmap.control.type               =  createMapfile
parmmap.control.method             =  add_suffix_to_file
parmmap.control.mapfile_in         =  createmap_target.output.mapfile
parmmap.control.add_suffix_to_file =  /instrument_amp_clock_offset
parmmap.control.mapfile_dir        =  input.output.mapfile_dir
parmmap.control.filename           =  targetparmdb.mapfile

# run NDPPP on the target data to flag, transfer calibrator values, and average
ndppp_trans_target.control.type                      = dppp
ndppp_trans_target.control.max_per_node              = 10                   # \ feel free to adjust these two values to match your system
ndppp_trans_target.control.environment               = {OMP_NUM_THREADS: 4} # / they should be reasonable for CEP3
ndppp_trans_target.control.error_tolerance           = {{ error_tolerance }}
ndppp_trans_target.argument.msin                     = createmap_target.output.mapfile    # The input data.
ndppp_trans_target.argument.msin.datacolumn          = DATA
ndppp_trans_target.argument.msin.baseline            = CS*&; RS*&; CS*&RS*
ndppp_trans_target.argument.msout.datacolumn         = DATA
ndppp_trans_target.argument.steps                    = [flag1,filter,flagamp,applyclock,applygain,applybeam,count,flag2,count,avg]
ndppp_trans_target.argument.flag1.type               = preflagger
ndppp_trans_target.argument.flag1.baseline           = [ CS013HBA* ]            # feel free to change that, but CS013 is usually bad.
ndppp_trans_target.argument.filter.type              = filter
ndppp_trans_target.argument.filter.baseline          = CS*, RS*&&
ndppp_trans_target.argument.filter.remove            = true                     # fully kick out the international stations.
ndppp_trans_target.argument.flagamp.type             = preflagger
ndppp_trans_target.argument.flagamp.amplmin          = 1e-30
ndppp_trans_target.argument.applyclock.type          = applycal
ndppp_trans_target.argument.applyclock.parmdb        = parmmap.output.mapfile
ndppp_trans_target.argument.applyclock.correction    = clock
ndppp_trans_target.argument.applygain.type           = applycal
ndppp_trans_target.argument.applygain.parmdb         = parmmap.output.mapfile
ndppp_trans_target.argument.applygain.correction     = gain
ndppp_trans_target.argument.applybeam.type           = applybeam
ndppp_trans_target.argument.applybeam.usechannelfreq = True
ndppp_trans_target.argument.flag2.type               = aoflagger
ndppp_trans_target.argument.flag2.keepstatistics     = false
ndppp_trans_target.argument.flag2.memoryperc         = 10
ndppp_trans_target.argument.flag2.strategy           = {{ flagging_strategy }}
ndppp_trans_target.argument.avg.type                 = average
ndppp_trans_target.argument.avg.timestep             = {{ avg_timestep }}       # average to 8 second intervals , PLEASE ADJUST!
ndppp_trans_target.argument.avg.freqstep             = {{ avg_freqstep }}       # average to 2 ch/SB , PLEASE ADJUST!

# run BBS to predict the A-Team contribution
ateamtarget.control.type             =  python-calibrate-stand-alone
ateamtarget.control.max_per_node     =  20                          # feel free to adjust this value to match your system
ateamtarget.control.error_tolerance  =  {{ error_tolerance }}
ateamtarget.argument.force           =  True
ateamtarget.argument.observation     =  ndppp_trans_target.output.mapfile
ateamtarget.argument.parset          =  {{ ATeam_predict_parset }}
ateamtarget.argument.catalog         =  {{ ATeam_skymodel }}

# run the a-team clipper to flag data affected by the a-team
ateamcliptar.control.kind               =  recipe
ateamcliptar.control.type               =  executable_args
ateamcliptar.control.max_per_node       =  24
ateamcliptar.control.mapfile_in         =  ndppp_trans_target.output.mapfile
ateamcliptar.control.executable         =  {{ ATeam_Clipper }}
ateamcliptar.control.error_tolerance    =  {{ error_tolerance }}
ateamcliptar.control.arguments          =  [allms]
ateamcliptar.control.inputkey           =  allms

# sort the target data into groups so that NDPPP can concatenate them
sortmap_tar.control.kind            =   plugin
sortmap_tar.control.type            =   groupMapfileObsSB
sortmap_tar.control.mapfile_dir     =   input.output.mapfile_dir
sortmap_tar.control.filename        =   sortmap_tar.mapfile
sortmap_tar.control.mapfile_in      =   ndppp_trans_target.output.mapfile
sortmap_tar.control.numSB           =   {{ num_SBs_per_group }}
sortmap_tar.control.NDPPPfill       =   True
sortmap_tar.control.truncateLastSBs =   True   # This means that a excess subbands that don't make a full group get discarded

# generate mapfile for the target skymodel
target_skymodel.control.kind        =   plugin
target_skymodel.control.type        =   addListMapfile
target_skymodel.control.hosts       =   [localhost]
target_skymodel.control.files       =   [{{ target_skymodel }}]
target_skymodel.control.mapfile_dir =   input.output.mapfile_dir
target_skymodel.control.filename    =   target_skymodel.mapfile

# make the sourcedb for the target skymodel
target_sourcedb.control.kind            =   recipe
target_sourcedb.control.type            =   executable_args
target_sourcedb.control.executable      =   {{ makesourcedb }}
target_sourcedb.control.args_format     =   lofar
target_sourcedb.control.outputkey       =   out
target_sourcedb.control.mapfile_in      =   target_skymodel.output.mapfile
target_sourcedb.control.inputkey        =   in
target_sourcedb.argument.format         =   <
target_sourcedb.argument.outtype        =   blob

# expand the sourcedb mapfile to every band
expand_target_sourcedb_map.control.kind             =   plugin
expand_target_sourcedb_map.control.type             =   expandMapfile
expand_target_sourcedb_map.control.mapfile_in       =   target_sourcedb.output.mapfile
expand_target_sourcedb_map.control.mapfile_to_match =   sortmap_tar.output.groupmap
expand_target_sourcedb_map.control.mapfile_dir      =   input.output.mapfile_dir
expand_target_sourcedb_map.control.filename         =   expand_target_sourcedb_map.mapfile

# run NDPPP to concatenate the target and average
dpppconcat_target.control.type                      =  dppp
dpppconcat_target.control.max_per_node              =  10                   # \ feel free to adjust these two values to match your system
dpppconcat_target.control.environment               =  {OMP_NUM_THREADS: 4} # / they should be reasonable for CEP3
dpppconcat_target.control.error_tolerance           =  {{ error_tolerance }}
dpppconcat_target.control.mapfiles_in               =  [sortmap_tar.output.mapfile,sortmap_tar.output.groupmap]
dpppconcat_target.control.inputkeys                 =  [msin,msout_unavg]
dpppconcat_target.argument.msin.datacolumn          =  DATA
dpppconcat_target.argument.msin.missingdata         =  True    #\ these two lines will make NDPPP generate dummy data when
dpppconcat_target.argument.msin.orderms             =  False   #/ concatenating data
dpppconcat_target.argument.steps                    =  [flag,out,avg,flaguv]
dpppconcat_target.argument.flag.type                =  aoflagger
dpppconcat_target.argument.flag.keepstatistics      =  false
dpppconcat_target.argument.flag.memoryperc          =  10
dpppconcat_target.argument.flag.strategy            =  {{ flagging_strategy }}
dpppconcat_target.argument.out.type                 =  out
dpppconcat_target.argument.out.name                 =  msout_unavg
dpppconcat_target.argument.avg.type                 =  average
dpppconcat_target.argument.avg.timestep             =  1
dpppconcat_target.argument.avg.freqstep             =  24       # average to 1 ch/concat-ed MS, PLEASE ADJUST!
dpppconcat_target.argument.flaguv.type              =  uvwflagger
dpppconcat_target.argument.flaguv.uvlambdamin       =  150

# generate mapfile with the direction-independent parmDBs
directionindependent_parmmap.control.kind               =  plugin
directionindependent_parmmap.control.type               =  createMapfile
directionindependent_parmmap.control.method             =  add_suffix_to_file
directionindependent_parmmap.control.mapfile_in         =  sortmap_tar.output.groupmap
directionindependent_parmmap.control.add_suffix_to_file =  /instrument_directionindependent
directionindependent_parmmap.control.mapfile_dir        =  input.output.mapfile_dir
directionindependent_parmmap.control.filename           =  targetparmdb.mapfile

# run NDPPP to calibrate on the target sourcedb
dpppcalib_target.control.type                      =  dppp_inplace
dpppcalib_target.control.max_per_node              =  10
dpppcalib_target.control.environment               =  {OMP_NUM_THREADS: 4} # / they should be reasonable for CEP3
dpppcalib_target.control.error_tolerance           =  {{ error_tolerance }}
dpppcalib_target.control.mapfiles_in               =  [dpppconcat_target.output.mapfile,expand_target_sourcedb_map.output.mapfile,directionindependent_parmmap.output.mapfile]
dpppcalib_target.control.inputkeys                 =  [msin,sourcedb,parmdb]
dpppcalib_target.argument.msin.datacolumn          =  DATA
dpppcalib_target.argument.msout                    =  .
dpppcalib_target.argument.steps                    =  [solvegain]
dpppcalib_target.argument.solvegain.type           =  gaincal
dpppcalib_target.argument.solvegain.caltype        =  phaseonly
dpppcalib_target.argument.solvegain.parmdb         =  parmdb
dpppcalib_target.argument.solvegain.sourcedb       =  sourcedb
dpppcalib_target.argument.solvegain.usebeammodel   =  True
dpppcalib_target.argument.solvegain.usechannelfreq =  True
dpppcalib_target.argument.solvegain.beammode       =  array_factor

# apply the solutions to the unaveraged, concatenated datasets
applytarget.control.type                  =  dppp_inplace
applytarget.control.max_per_node          =  10
applytarget.control.environment           =  {OMP_NUM_THREADS: 4} # / they should be reasonable for CEP3
applytarget.control.error_tolerance       =  {{ error_tolerance }}
applytarget.control.mapfiles_in           =  [sortmap_tar.output.groupmap,directionindependent_parmmap.output.mapfile]
applytarget.control.inputkeys             =  [msin,parmdb]
applytarget.argument.msin.datacolumn      =  DATA
applytarget.argument.msout                =  .
applytarget.argument.msout.datacolumn     =  CORRECTED_DATA
applytarget.argument.steps                =  [applygain]
applytarget.argument.applygain.type       =  applycal
applytarget.argument.applygain.parmdb     =  parmdb
applytarget.argument.applygain.correction =  gain

# plot the phase solutions from the phase-only calibration of the target
plot_target_phases.control.kind         =  recipe
plot_target_phases.control.type         =  executable_args
plot_target_phases.control.executable   =  {{ plotphases_script }}
plot_target_phases.control.max_per_node =  24
plot_target_phases.control.mapfiles_in  =  [directionindependent_parmmap.output.mapfile,sortmap_tar.output.groupmap]
plot_target_phases.control.inputkeys    =  [infile,outbase]
plot_target_phases.control.arguments    =  [-p,infile,outbase]

# make mapfile with the filenames of the results that we want
make_results_mapfile.control.kind            =  plugin
make_results_mapfile.control.type            =  makeResultsMapfile
make_results_mapfile.control.mapfile_dir     =  input.output.mapfile_dir
make_results_mapfile.control.filename        =  make_results_mapfile.mapfile
make_results_mapfile.control.mapfile_in      =  sortmap_tar.output.groupmap
make_results_mapfile.control.target_dir      =  {{ results_directory }}
make_results_mapfile.control.make_target_dir =  True
make_results_mapfile.control.new_suffix      =  .pre-cal.ms

# move the results to where we want them
move_results.control.kind               =  recipe
move_results.control.type               =  executable_args
move_results.control.executable         =  /bin/mv
move_results.control.max_per_node       =  20                                 # feel free to adjust this value to match your system
move_results.control.mapfiles_in        =  [sortmap_tar.output.groupmap,make_results_mapfile.output.mapfile]
move_results.control.inputkeys          =  [source,destination]
move_results.control.arguments          =  [source,destination]

# generate a mapfile of all the diagnostic plots
createmap_plots.control.kind            =   plugin
createmap_plots.control.type            =   createMapfile
createmap_plots.control.method          =   mapfile_from_folder
createmap_plots.control.mapfile_dir     =   input.output.mapfile_dir
createmap_plots.control.filename        =   diagnostic_plots.mapfile
createmap_plots.control.folder          =   input.output.working_directory/input.output.job_name
createmap_plots.control.pattern         =   *.png

# copy the diagnostic plots to the results_directory
copy_plots.control.kind               =  recipe
copy_plots.control.type               =  executable_args
copy_plots.control.executable         =  /bin/cp
copy_plots.control.max_per_node       =  20                                 # feel free to adjust this value to match your system
copy_plots.control.mapfile_in         =  createmap_plots.output.mapfile
copy_plots.control.inputkey           =  source
copy_plots.control.arguments          =  [source,{{ results_directory }}]
